---
layout: default
---

## 函数

在写大型项目中，像之前那样不停的在`main`里边添加内容，会让程序越来越难以阅读和维护。

函数这个词和数学意义里的函数相似、但又不同。

可以通过这样的方式定义一个函数。

```cpp
int max(int x, int y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}
```

通过这样的方式调用一个函数。

```cpp
int main() {
    int a = 0, b = 0;
    scanf("%d%d", &a, &b);
    int c = max(a, b);
    printf("%d\n", c);
    return 0;
}
```

上面的例子中，`x`, `y`称为函数的"形参"，作为函数内的代号。
`a`, `b`为函数的"实参"，为函数真正传入的参数。

函数的存在可以简化代码，使其更加简单易懂。

与数学中的函数不同的是，C++中的函数只是一个**代码片段**，可能是有副作用的，会对外界造成影响。

如我们之前的排序，也可以写成一个函数。

```cpp
void sort(int a[], int n) {
    // Something here...
}
```

返回值为void类型代表没有信息需要返回。这时可以不写return函数。

### 函数重载

我们之前写的max函数，参数是两个int类型，如果我们传入两个float类型，会怎么样呢？

答案是会自动被程序转换为int类型再调用。这种转换其实并不太好，因为int类型表示的范围比float小。

一个可行的方案是再写一个`max_float`函数，但更好的方式是使用函数重载。
仍使用`max`这个函数名，但参数和返回值类型写成`float`即可。

调用函数时，编译器会根据调用的数据类型，智能的匹配应该调用哪一个函数。
如果他无法选择出来，则会编译报错，要求你把类型转换为可以精确匹配后在传入。

通过这个例子，我们可以发现，编译系统使用"函数名+函数参数类型"作为一个函数的签名（标识）。
形参的名字、返回值的类型，均不在函数签名内。

应当慎用函数重载，应当只在两个函数做的是**完全相同**的事情的时候才使用重载。如之前的`max`例子。

函数参数还可以有默认值，写法如下。

```cpp
int calculate(int n, int s=0) {
}
```

调用时可以写`calculate(n)`，或者`calculate(n, s)`。

默认值只能是函数的最后若干个参数，调用时也只能省略最后若干个参数。

函数的默认参数也应当慎用。

### 变量的作用域和生命周期

在如下代码中，你会发现编译报错：

```cpp
int find(int a[], int n, int x) {
    for (int i = 0; i < n && a[i] != x; i++) {
    }
    return i;
}
```

报错的原因是，变量`i`只存在于for循环内，出了for循环就不在了。

这个范围叫做变量的**作用域**，指的是在哪个范围内可以通过这个名字找到这个变量。

变量的作用域为，声明变量时，所在的那个大括号内。
for循环比较特殊，for循环的循环变量的作用域在循环体内。

变量的生命周期是指，这个变量在什么时候开始在内存中有意义，在什么时候变得没有意义，可以被销毁并被其他变量占据。

变量的生命周期通常与变量的作用域相同，因为在绝大多数情况下，访问不到这个变量，我们也就不再关心它了。

### 全局变量

在函数体外声明的变量，称为全局变量。对应的，在函数体内声明的称为局部变量。

全局变量的生命周期与整个程序相同，在程序最初进行初始化，直到程序结束才消失。

### 静态变量

可以使用`static`关键字在函数体内声明静态变量，静态变量的作用域与局部变量相同，但生命周期与整个程序相同。

静态变量会在程序最初预留对应大小的内存，在第一次运行到声明语句时进行初始化。

```cpp
void print() {
    static int count = 1;
    printf("This is %dth print.\n");
}
```

### 递归

函数的真正威力在于，他可以调用自己。这种方法叫做递归。

如以下例子求出某个数字的阶乘。

```cpp
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```

实际上，我们使用循环也可以完成类似的事情。

```cpp
int factorial(int n) {
    int ans = 1;
    for (int i = 2; i <= n; i++) {
        ans = ans * i;
    }
    return ans;
}
```

所有的递归都可以用循环的方式来实现，
只不过有的会比较好写（如阶乘），有的会比较难写（如归并排序）。

### 汉诺塔

写一个函数输出汉诺塔问题的解法。

### 快速幂

写一个函数实现a的n次幂，思考一下有什么办法优化时间复杂度。

### 快速排序

快速排序的思路是，首先找到某一个数字在这个序列中的真正的位置，
然后这个序列就会被分为两部分（小于这个数字的，和大于等于这个数字的）。
接下来对这两部分分别进行快速排序。

思考一下他的时间复杂度是多少？有什么办法优化？

### 归并排序

归并排序的思路是，首先把这个序列的两个子段分别排好序，然后把他们合并起来。

思考一下他的复杂度是多少？相比快速排序有什么优劣？

### 排序算法

基于比较的排序算法，复杂度最低为$$O(n\log(n))$$。试证明

### 线性时间排序算法

假如数字的范围都在100以内，有什么更快的方法呢？

假如为int范围，该怎么做呢？

假如为0~1的浮点数，又该怎么做呢？

### 栈溢出

使用之前的阶乘算法，计算一下$$10^8$$的阶乘（先不考虑整数溢出的问题）。

尝试手算模拟一下递归的过程，你会发现不得不需要用一些空间存储函数的参数和局部变量。这个内存空间称为栈空间。

与全局变量不同，局部变量分配在"栈空间"上。当栈空间被耗光时，就会发生栈溢出。

所以递归的深度不宜过深，局部变量也不宜占用大量空间。如需要存储一个巨大的数组，应当使用全局变量，或者动态内存分配。

## 指针

指针是一种特殊的变量，他存储了一个其他变量的"地址"。

通过`&`运算符可以取一个变量的地址，如我们常用的`scanf`语句，就是把变量的地址传了过去。

通过`*`运算符可以给指针解引用，操作这个指针指向的变量，修改变量的值。

```cpp
int a = 0;
int *b = &a;
*b = 3;
printf("%d\n", a);
```

上面的代码看似没有直接修改a的值，但指针b记录了变量a的地址，通过指针b，修改了变量a的值。

当一个函数需要返回多个值时，一个常用的方式就是传递多个指针到函数中。

```cpp
void min_max(int a[], int n, int *maxv, int *minv) {
    *maxv = -INF;
    *minv = INF;
    for (int i = 0; i < n; i++) {
        if (a[i] > *maxv) {
            *maxv = a[i];
        }
        if (a[i] < *minv) {
            *minv = a[i];
        }
    }
}
```

如上面的函数展示了如何传入两个指针，并通过他们把值返回回去。

数组作为函数的参数，本质上和指针非常相似，数值上就是指向数组第一个元素的指针。
如`sort(int a[], int n)`，其实也可以写成`sort(int *a, int n)`。

### 变量的引用

观察上面的内容，我们发现每次用到maxv和minv的时候，前面都有一个星号。

这样略微有些麻烦，所以C++引入了一种稍微简单些的写法。

```cpp
void min_max(int a[], int n, int &maxv, int &minv) {
    maxv = -INF;
    minv = INF;
    for (int i = 0; i < n; i++) {
        if (a[i] > maxv) {
            maxv = a[i];
        }
        if (a[i] < *minv) {
            minv = a[i];
        }
    }
}
```

通过`int &maxv`的形式，我们按照**引用方式**声明了变量。

这种写法本质上与前面的指针方式没有任何区别。

### 动态内存分配

通过`new`关键字可以使用"动态内存分配"的方式创建变量。

动态内存分配创建的变量在"堆空间"内，不在"栈空间"内，不受变量生命周期控制，需要自己管理生命周期，使用`delete`关键字释放空间。

```cpp
int *x = new int;  // 创建一个普通变量
int *a = new int[3];
delete x;
delete a;
```

使用动态内存分配要非常小心，如果创建了一个变量，然后不小心把他对应的指针覆盖了，这样就再也没法找到这个变量，而他还会一直占用内存，就会产生**内存泄漏**。
如果创建了一个变量，对其进行了多次`delete`操作，就会发生**二次释放**。

### 链表

链表是一个数据结构，其中每一个节点包含一个指针，指向下一个元素。

相较于数组，链表能够用更低的成本在中间位置插入和删除元素，但随机查找元素的复杂度较高。

实现一个链表类。实现对一个链表进行归并排序。
